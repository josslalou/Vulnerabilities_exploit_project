
#pip install anytree
import anytree
import idautils
import idc
import idaapi
import ida_xref
import copy
import ida_kernwin

FUNCTION_TO_ANALYSE = ['scanf', 'sscanf', 'printf', 'strcmp','strcpy','_strncmp','_scanf','_printf','_fgetc','strcpy','_strcat','_strlen','_strcmp','fgets']
principal_func=[]
FUNCTION=['scan','print','cpy','cmp','get']
   
###################################### FUNCTIONS OF INITIALISATION #############################################

"""get all function from the ida """
def find_all_function():
    func_tab=[]
    for addr in idautils.Functions():
        name = idc.get_func_name(addr)
        xrefs = idautils.CodeRefsTo(addr, False)
        my_func = Function(addr,name)
        my_func.set_xref_tab(xrefs)
        func_tab.append(my_func)
    return func_tab
   
     
"""sort all function by name in a new tab"""    
def sort_all_function(func_tab):
    vul_func_tab = []
    for fun in func_tab:
        for i in FUNCTION:
            if i in fun.name :
                for addr in fun.xref_tab:
                    name = fun.name
                    xrefs = idautils.CodeRefsTo(addr, False)
                    my_func = Function(addr,name)
                    my_func.set_xref_tab(xrefs)
                    vul_func_tab.append(my_func)
    return vul_func_tab


''' 
refrech a function :
if a function have a xref_tab not empty , thats mean that the adress where she is called 
is the adress in the xref_tab.
we refrech this func in order to make the func.addr = to the adress in the xref_tab
and set the xref_tab to []
'''
def init_function(fun):
    for addr in fun.xref_tab:
        name = fun.name
        xrefs = idautils.CodeRefsTo(addr, False)
        fun.set_addr(addr)
        fun.set_name(name)
        fun.trace_back()
        if len(list(xrefs))==0:
            fun.clear_xref_tab()
############################################## END OF INIT #######################################


############################################## ACTION ON FUNC_TAB #############################

"""return True if the func in the tab """       
def func_in_tab(func,tab):
    for function in tab:
        if func.name==function.name and func.addr==function.addr:
            return True
    return False    

""" Print all the tab """
def print_tab_function(func_tab):
    for fun in func_tab:
        fun.to_str()

##############################################END ACTION ON FUNC_TAB #############################



####################################### TRACE BACK #####################################

def trace_back_func_tab(func_tab):
    for fun in func_tab:
        fun.trace_back()

def trace_back_from_above_tab(head,func_tab):
    for fun in func_tab:
        fun.trace_back_from_above()

def trace_back_param_64bit(fun):
    dict = {}
    instruction_tab = ['call', 'align', 'jmp', 'ret', 'retn', 'b']
    
    register_tab = ["rcx", "ecx", "rdx", "edx", "r8","r8d", "r9","r9d"]
    addr = fun.addr
    head_func = idc.get_func_attr(addr, idc.FUNCATTR_START)
    prev_addr = (prev_head(addr))
    op = idc.print_insn_mnem(prev_addr).lower()
    while op != 'call':
        if prev_addr <= head_func:
            break
    
        dst = idc.print_operand(prev_addr, 0)
        if dst in register_tab:
            register_tab.remove(dst)
            for re in register_tab:
                if dst[1] in re:
                    register_tab.remove(re)
            fun.set_dict_arg_adress(prev_addr, dst)
                
        prev_addr = (prev_head(prev_addr))
        op = idc.print_insn_mnem(prev_addr).lower()


def trace_back_value_64bit(fun):
    a=0;
    temp=""
    break_tab = ["ret", "retn", "jmp", "b", "call"]
    
    for key in fun.dict_arg_adress:
        addr = key
        head_func = idc.get_func_attr(addr, idc.FUNCATTR_START)
        src = idc.print_operand(addr, 1)  # r11 4010d1

        prev_addr = (prev_head(addr))
        op = idc.print_insn_mnem(prev_addr).lower()
        while op != 'call':
            if prev_addr <= head_func or op in break_tab:
                if head_func != 18446744073709551615:
                    break
            dst = src
            if dst[1:] == idc.print_operand(prev_addr, 0)[1:]:  # car eax = rax
                src = tohen_register(idc.print_operand(prev_addr, 1))  # rax
                a=prev_addr
            if a!=0:
                disas = idc.GetDisasm(a)# à remplacer par une addresse de notre choix
                temp = get_comment(disas)
                key=a
            else:            
                disas = idc.GetDisasm(key)# à remplacer par une addresse de notre choix
                temp = get_comment(disas)
                    
            prev_addr = (prev_head(prev_addr))
            op = idc.print_insn_mnem(prev_addr).lower()
        
        
        if temp!=-1:
            src=src+temp     
                   
        fun.set_dict_arg_value(key, src)
        key=0
   

def trace_back_param_32bit(fun):
    
    break_tab = ["ret", "retn", "jmp", "b", "call"]
    addr = fun.addr
    head_func = idc.get_func_attr(addr, idc.FUNCATTR_START)
    prev_addr = (prev_head(addr))
    op = idc.print_insn_mnem(prev_addr).lower()
    while op != 'call':
        if prev_addr <= head_func or op in break_tab:
            if head_func != 18446744073709551615:
                break
        dst = idc.print_operand(prev_addr, 0)
        if op == 'push' and dst != 'ebp':
            fun.set_dict_arg_adress(prev_addr, dst)
        prev_addr = (prev_head(prev_addr))
        op = idc.print_insn_mnem(prev_addr).lower()
    

def trace_back_value_32bit(fun):
    a=0
    temp=""
    break_tab = ["ret", "retn", "jmp", "b", "call"]
    for key in fun.dict_arg_adress:
        addr = key
        head_func = idc.get_func_attr(addr, idc.FUNCATTR_START)
        src=idc.print_operand(addr, 0)
        prev_addr = (prev_head(addr))
        op = idc.print_insn_mnem(prev_addr).lower()
        while op != 'call':
            if prev_addr <= head_func or op in break_tab:
                if head_func != 18446744073709551615:
                    break
            dst = src          
            if op in ('mov','lea') and dst[1:] == idc.print_operand(prev_addr, 0)[1:]:
                src = tohen_register(idc.print_operand(prev_addr, 1))
                a=prev_addr
                if a!=0:
                    disas = idc.GetDisasm(a)# à remplacer par une addresse de notre choix
                    temp = get_comment(disas)
                    key=a
                else:            
                    disas = idc.GetDisasm(key)# à remplacer par une addresse de notre choix
                    temp = get_comment(disas)
                
            prev_addr = (prev_head(prev_addr))
            op = idc.print_insn_mnem(prev_addr).lower()
        
            
        if temp!=-1:
            src=src+temp     
                       
        fun.set_dict_arg_value(key, src)
        key=0
     
           
   
####################################### END TRACE BACK #################################################
                                                                                                               
def get_comment(string):
    index1 = string.find(';')
    if index1 != -1:
        temp = string[index1::]
        return temp
    return index1
    
def cut_comment_by_utility(comment):
    List_formats = ''
    for i in comment :
        if i =='%':
            List_formats+=(comment[comment.index(i):])
            break
    parameters = List_formats.split('%')
    return List_formats
    
    
def tohen_register(right):
    if right.count('[') == 1 and right.count(']')==1:
        return right[1:len(right)-1]
    else :
        return right 
        
   
     
def check_this_param_in_the_stack(big_fun,index):
    check_param_in_the_stack(big_fun)

def get_arg_number(big_fun,arg,arg_var):
    tab=[]
    for item in big_fun.dict_stack.items():
        if item[1] in arg_var:
            tab.append(item[1])
    return tab.index(arg)+1
                                          
def get_size_of_var(var,big_fun):

    if "offset" in var or 'edi' in var or "%s" in var:
        return str(0)
        
    var_size=0
    base=0
    flag=False
    value=[]
    var_tab=[]
    for item in big_fun.dict_stack.items():
        value.append(item[0])
        var_tab.append(item[1])
    
    index=var_tab.index(var)
        
    return str(value[index+1]-value[index])
     
         
            
      
######################################### A REDEFINIR ###########################################
 

def check_param(fun,fun2):
    for item in fun.dict_arg_value.items():
        for item2 in fun2.dict_arg_adress.items():
            if item[1] == item2[1]:
                fun.set_dict_arg_value(item[0], fun2.dict_arg_value[item2[0]])
################################################ A REDEFINIR ####################################################               
                
############################################# GET PRINCIPAL FUNC ######################################################
"""
get all the principal function (like main , start , ...)
return a tab with all this functions
"""                                                                                                           
def define_in_function(vul_function_tab,all_func_tab):
    big_func=[]
    vul_func_tab=vul_function_tab.copy()
    for vul_func in vul_func_tab:
        for func in all_func_tab:
            if idc.get_func_attr(vul_func.addr, idc.FUNCATTR_START) == func.addr:
                vul_func.set_in_function(func.addr,func.name)
                new_func=copy.deepcopy(func)
                find_stack_members(new_func)
                init_function(new_func)
                if not func_in_tab(new_func, vul_func_tab) and not func_in_tab(new_func, all_func_tab) :
                    vul_func_tab.append(new_func)
                    big_func.append(new_func)
                if func.xref_tab==[]:
                    big_func.append(new_func)
                                                        
    return big_func
                
############################################# END PRINCIPAL FUNC ######################################################


############################################# GET STACK VALUE ########################################################

"""
get the stack of all function in the tab
"""
def get_the_stack(fun_tab):
    for fun in fun_tab:
        find_stack_members(fun)

"""
get the stack of the function 
init the dict stack of the function
"""
def find_stack_members(func):
    members = {}
    base = None
    frame = idc.get_frame_id(func.addr)
    if frame:
        for frame_member in idautils.StructMembers(frame):
            member_offset, member_name, _ = frame_member
            func.set_dict_stack(member_offset ,member_name)
            if member_name == ' r':
                base = member_offset
                func.set_stack_base(base)
    """if not base:
        raise ValueError("Failed identifying the stack's base address")"""  
        
############################################# END STACK VALUE ########################################################
  
    
################################# CLASS #######################################
class Function:

############# empty constructor ############ 
    def __init__(self,addr,name):
        self.addr =addr
        self.name = name
        self.xref_tab = []
        self.dict_arg_adress = {}
        self.dict_arg_value = {}
        self.dict_stack={}
        self.dict_in_function={}
        self.stack_base=0
        
        self.trace_back()

############### setters #####################
    def set_addr(self, param):
        self.addr = param
        
    def set_name(self, param):
        self.name = param

    def set_xref_tab(self, param):
        for i in param:
            self.xref_tab.append(i)
        
    def set_dict_arg_adress(self, addr, arg):
        self.dict_arg_adress[addr] = arg

    def set_dict_arg_value(self, addr, arg):
        self.dict_arg_value[addr] = arg
        
    def set_dict_stack(self, addr , name):
        self.dict_stack[addr] = name
        
    def set_in_function(self, index , name):
        self.dict_in_function[index] = name
    
    def set_stack_base(self,base):
        self.stack_base=base

####################### functions #################################  
     
    def to_str(self):
        print("\nname of the function:     " + self.name +
              "\nadress of the function:   " + hex(self.addr))
        print("in the function          " , end=" ")
        print(dict(map(lambda x: (hex(x[0]), x[1]), self.dict_in_function.items())))
        print("adress of the xref_to    ", end=" ")
        print(list(map(lambda x: hex(x), self.xref_tab)))
        print("dict of the param-addr   ", end=" ")
        print(dict(map(lambda x: (hex(x[0]), x[1]), self.dict_arg_adress.items())))
        print("dict of the param-value  ", end=" ")
        print(dict(map(lambda x: (hex(x[0]), x[1]), self.dict_arg_value.items())))
        print("dict of stack            ", end=" ")
        print(dict(map(lambda x: (x[0], x[1]), self.dict_stack.items())))
        print("base of the stack         " + str(self.stack_base))
        
    def print_dict(self,dict):
        print(dict(map(lambda x: (hex(x[0]), x[1]), dict.items())))
        
    
    def trace_back(self):
        info = idaapi.get_inf_structure()
        if info.is_64bit():
            trace_back_param_64bit(self)
            trace_back_value_64bit(self)
        else:
            trace_back_param_32bit(self)
            trace_back_value_32bit(self)
            
    def trace_back_from_above(self):
        check_param_in_the_stack(self)
            
    def add_xref_tab(self, param):
        self.xref_tab.append(param) 
               
    def clear_xref_tab(self):
        self.xref_tab.clear()        

####################################### END CLASS ######################################
   
####################################### CLASS TREE ######################################
        
class Tree(Function,anytree.NodeMixin):
    def __init__(self, name,fun, parent=None, children=None):
        self.function=fun
        self.name = name
        self.parent = parent
        if children:  # set children only if given
         self.children = children                

####################################### END CLASS ######################################
####################################### TREE FUNC ######################################
def init_tree( princ_func,vul_tab):
    princip_func=princ_func.copy()
    vul_func_tab=vul_tab.copy()
    head=Tree("init",Function(0,'init'))
    for fun in princip_func:
        if fun.dict_in_function == {} and 'start' == fun.name.lower():
            head=Tree(fun.name,fun)
    
    create_all_node(head,princip_func)       
    for fun in vul_tab:
        for item in fun.dict_in_function.items():
            if anytree.search.find(head,lambda node : node.name==item[1]):
                Node=Tree(fun.name,fun,anytree.search.find(head,lambda node : node.name==item[1]))
                  
    return head
    

def create_all_node(head,tab):

    for i in range(3):
        for fun in tab:
            for item in fun.dict_in_function.items():
                if head.function.name==item[1]:
                    Node=Tree(fun.name,fun,anytree.search.find(head,lambda node : node.name==item[1]))
                    tab.remove(fun)
                    create_all_node(Node,tab)
    

def print_tree(head):                                                                        
    for pre, fill, node in anytree.RenderTree(head):
         print("%s%s" % (pre, node.name))
		 
####################################### END TREE FUNC ######################################
def trace_back_from_tree(head,vul_func_tab):
    for fun in vul_func_tab:
        node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
        if node:
            print(fun.name)
            for item in node.function.dict_arg_value.items():
                check_arg(head,node,item[1])
            print("\n")    

def trace_back_from_fun(head,fun):
        node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
        if node:
            print(fun.name)
            for item in node.function.dict_arg_value.items():
                check_arg(head,node,item[1])
            print("\n")  
            
def check_arg(head,node,arg,local_flag):

    
    if node==head:
        parent=node
    else:
        parent=node.parent        
    
    str=""
    for B_item in parent.function.dict_stack.items():
        str+=B_item[1]
    str=str.split(" r")
    local_var=str[0]
    arg_var=str[1]    
    
    flag=local_flag                                      
    for item in parent.function.dict_stack.items():
        if item[1] in arg and item[1] != " s" and item[1] != " r":
            if item[1] in local_var:
                #print(item[1]+"  " + "in the local area come from "+ parent.function.name +" stack")
                #print(get_size_of_local_var(B_item[1],big_fun))
                return flag,item[1],parent.function 
            else:
                #print(item[1]+"  " + "come from  "+parent.function.name+" param number :", end="")
                return check_arg_by_index(head,parent,get_arg_number(parent.function,item[1],arg_var),False)  
                
        elif 'offset' in arg or arg[0]=='a' or 'format' in arg.lower() or 'edi' in arg:
            return False,arg,parent.function        
                                                                                      
def check_arg_by_index(head,node,index,local_flag):
    i=1
    flag=False
    fun=node.function
    for item in node.function.dict_arg_value.items():
        if i == index:
            arg=item[1]
            if item[0]!=0:
                flag,arg,fun=check_arg(head,node,item[1],local_flag)
            i=i+1 
            if flag:
                return flag,arg,fun    
        else: 
            i=i+1                                                                             
    return flag,arg,fun


def arg_used_in_input_function(arg,fun,big_fun):
    fun_in_big_fun=anytree.search.findall(head,lambda node : "get" in node.function.name or "scan" in node.function.name)
    for node in fun_in_big_fun:
        for item in node.function.dict_arg_value.items():
            if arg in item[1] :#and fun.addr>node.function.addr:
                return node.function
    return False    

        
def get_value_of_param(fun,index):
    i=1
    for item in fun.dict_arg_value.items():
        if i == index:
            i=i+1
            my_str=item[1]
            index1 = my_str.find(';')
            if index1 != -1:
                format=cut_comment_by_utility(my_str[index1:])
                if format:
                    return format
                    
            else:
                if my_str[len(my_str)-1]=='h':
                    value=my_str[0:len(my_str)-1]
                    return(int(value,base=16))
                else:
                    return str(0)
                                         
        else:
            i=i+1                       
                    
                          
def analyse_format(format): 
    precise=True
    format=format.replace('"',"")        
    temp1 = format.split('%')
    
    my_lenght = len(temp1) - 1
    print("The size of our format is : ", my_lenght)
    New_array = []
    count = 0
    for i in temp1[1:]:
        count += 1
        if 's' in i and i != 's':
            New_array.append(["precised string for index number ", count,i[:i.index('s')], i])
            
        else:
            New_array.append(['not precised in index number : ', count, i])
            precise=False

    print(New_array)
    return precise
   
##############################################################  ATTACKS ##############################################"

def check_attack(head,vul_tab,tcc):

    for fun in vul_tab:            
    ###############  OVERFLOW ATTACK ##############                            
        if "scan" in fun.name:                           # check scan function
            check_scan_attack(head,fun,tcc)
        elif "get" in fun.name:                           # check scan function
            check_get_attack(head,fun,tcc)                                                    
        elif "cpy" in fun.name:
            check_cpy_attack(head,fun,tcc)                       
    ###############  FORMAT STRING ATTACK ##############                                                                                                                                                                                                                                                                                                                                                                                 
        elif "printf" in fun.name:
            check_print_attack(head,fun,tcc)                            
    ###############  BUFFER OVERRUN ATTACK ##############                                                                                                                                                                                                                                                                                                                                                                                                
        elif "cmp" in fun.name:
             check_strcmp_attack(head,fun,tcc)
        
              

                                                     
def check_scan_attack(head,fun,tcc):
    
    if fun.name=='scanf' or fun.name=='_scanf':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg>=2 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                if tcc:
                    local,arg,big_fun=check_arg_by_index(head,node,1,1)
                    format=get_value_of_param(fun,2)
                    format_precise=analyse_format(format)
                else:
                    local,arg,big_fun=check_arg_by_index(head,node,2,1)
                    format=get_value_of_param(fun,1)
                    
                    format_precise=analyse_format(format)
                if local and big_fun==node.parent.function and not format_precise:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" with a format non precise in the function "+ big_fun.name+"  "+hex(big_fun.addr))
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" with a format non precise from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
                        
        if nb_of_arg==1 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                local,arg,big_fun=check_arg_by_index(head,node,1,1)
                if local and big_fun==node.parent.function:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" with a format non precise in the function "+ big_fun.name+"  "+hex(big_fun.addr))
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" with a format non precise from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
                                     
    elif fun.name=='sscanf' or fun.name=='_sscanf':
        return 0
    
    elif fun.name=='scanf_s' or fun.name=='_scanf_s':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg==3 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                local,arg,big_fun=check_arg_by_index(head,node,2,1)
                format=get_value_of_param(fun,1)
                format_precise=analyse_format(format)
                counter=get_value_of_param(fun,3)
                if local and big_fun==node.parent.function and not format_precise:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" with a format non precise in the function "+ big_fun.name+"  "+hex(big_fun.addr))
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
        


def check_get_attack(head,fun,tcc):
    
    if fun.name=='gets' or fun.name=='_gets':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg>=2 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                if tcc:
                    local,arg,big_fun=check_arg_by_index(head,node,1,1)
                    format=get_value_of_param(fun,2)
                    format_precise=analyse_format(format)
                else:
                    local,arg,big_fun=check_arg_by_index(head,node,2,1)
                    format=get_value_of_param(fun,1)
                    format_precise=analyse_format(format)
                if local and big_fun==node.parent.function and not format_precise:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" with a format non precise in the function "+ big_fun.name+"  "+hex(big_fun.addr))
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" with a format non precise from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
                        
        if nb_of_arg==1 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                local,arg,big_fun=check_arg_by_index(head,node,1,1)
                if local and big_fun==node.parent.function:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" with a format non precise in the function "+ big_fun.name+"  "+hex(big_fun.addr))
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" with a format non precise from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
                        
                                        
                        
        
def check_print_attack(head,fun,tcc):

    if fun.name=='printf' or fun.name=='_printf':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg==1 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                local,arg,big_fun=check_arg_by_index(head,node,1,1)
                if local:
                    from_func = arg_used_in_input_function(arg,fun,node.parent)
                    if from_func: 
                        print("\nPOSSIBLE VULNERABILITY STRING ATTACK")
                        print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+" set by "+from_func.name+ " in the function "+ big_fun.name )
                    else:
                        print("\nPOSSIBLE VULNERABILITY STRING ATTACK") 
                        size=get_size_of_var(arg,big_fun)
                        print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                        if big_fun.name=="start":
                            print("input by cmd line")
    
     
def check_cpy_attack(head,fun,tcc):

    if fun.name=='strcpy' or fun.name=='_strcpy':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg==2 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                if tcc:
                    local,arg,big_fun=check_arg_by_index(head,node,1,1)
                else:
                    local,arg,big_fun=check_arg_by_index(head,node,2,1)
                if "offset" in arg or "edi" in arg:
                    return
                if local :
                    if big_fun.name==head.function.name: 
                        print("\nPOSSIBLE VULNERABILITY OVERFLOW")
                        print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+" in the function "+ big_fun.name+" come from cmd line")
                else:
                    print("\nPOSSIBLE VULNERABILITY OVERFLOW") 
                    size=get_size_of_var(arg,big_fun)
                    print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                    if big_fun.name=="start":
                        print("input by cmd line")
                                   
                                                                           
def check_strcmp_attack(head,fun,tcc):

    if fun.name=='strcmp' or fun.name=='_strcmp':
        nb_of_arg=len(fun.dict_arg_value)
        if nb_of_arg>=2 and len(fun.dict_in_function):
            node=anytree.search.find(head,lambda node : node.function.addr==fun.addr)
            if node:
                if tcc:
                    local,arg,big_fun=check_arg_by_index(head,node,1,1)
                else:
                    local,arg,big_fun=check_arg_by_index(head,node,2,1)
                if "offset" in arg:
                    return
                if local:
                    from_func = arg_used_in_input_function(arg,fun,node.parent)
                    if from_func: 
                        size=get_size_of_var(arg,big_fun)
                        print("\nPOSSIBLE VULNERABILITY OVERRUN") 
                        print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" set by "+from_func.name+ " in the function "+ big_fun.name )
                    else:
                        size=get_size_of_var(arg,big_fun)
                        print("\nPOSSIBLE VULNERABILITY OVERRUN") 
                        print(fun.name+"  "+hex(fun.addr)+"  use the local var : "+arg+' ('+size+')'+" in the function "+ big_fun.name )
                else:
                    from_func = arg_used_in_input_function(arg,fun,node.parent)
                    if from_func: 
                        size=get_size_of_var(arg,big_fun)
                        print("\nPOSSIBLE VULNERABILITY OVERRUN") 
                        print(fun.name+"  "+hex(fun.addr)+"  use var : "+arg+' ('+size+')'+" set by "+from_func.name+ " in the function "+ big_fun.name )
                    else:
                        print("\nPOSSIBLE VULNERABILITY OVERRUN") 
                        size=get_size_of_var(arg,big_fun)
                        print(fun.name+"  "+hex(fun.addr)+"  use var: "+arg+' ('+size+')'+" from the stack of the function "+ big_fun.name+"  "+hex(big_fun.addr))
                        if big_fun.name=="start":
                            print("input by cmd line") 


                                                                                                                                                                                                                                                                                                                                                                              
if __name__ == "__main__":


    ida_kernwin.beep()
    all_func_tab = find_all_function()                               # get all functions
    
    vul_func_tab = sort_all_function(all_func_tab)                   # get vuln function
    principal_func = define_in_function(vul_func_tab, all_func_tab)  # get principal func fonction mère 
    
    
    
    head=init_tree(principal_func,vul_func_tab)                      # create a tree of the functions
    print("____TREE OF THE IDA VULNERABLE FUNCTION____\n")
    print_tree(head)                                                 # print the Function Tree
    print("\n")
    
   
    
    #trace_back_from_above_tab(head,vul_func_tab)                    # where the param come from of vul_func
    #trace_back_from_tree(head,vul_func_tab)
   
    
    print_tab_function(vul_func_tab)                                 # print list of vul func
    print_tab_function(principal_func)                               # print list of principal func 
    print("\n")
    
    answer=ida_kernwin.ask_yn(0,"Welcome in Vulscan \n Are you ready ? ")
    if answer:
        info = idaapi.get_inf_structure()
        if info.is_64bit():
            check_attack(head,vul_func_tab,1)
        else:
            check_attack(head,vul_func_tab,0)
    
    
    

